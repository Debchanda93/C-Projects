Pointers:

Two ways to store a variable: STACK and HEAP.

Usually they are stored as STACK. When functions are written, it allocates variable in the STACK. After function is over, it deallocates the variables. 
HEAP allows the variable to stay.

Pointer pointing to NULL is a safety net. Whenever we dont have value to point to, the pointer should point to NULL. 

Pointers are usefull for allocating HEAP-DYNAMIC MEMORY and pointing towards it. MEMORY LEAK is when the pointer (pointing to the heap-dynamic memory) is lost. 
DOUBLE DELETE will crash the program. So be careful. 
Deleting NULL Pointer has no effect. 

SORTING: There are several sorting algos.
1. Selection-sort
2. Insertion-sort
3. Bubble-sort
4. Merge-sort
5. Heap-sort
6. Quick-sort.......etc

OBJECT ORIENTED PROGRAMMING
.............................

CLASS : are framework that helps creating multiple objects. Think of it as a blueprint for a house. Its an object initiator. We don't want to live in the blueprint 
but in the houses that are made from the blueprint. 

ENCAPSULATION: codes written as part of the class have better access to the class than codes that are not. 

A CLASS is an abstract data type. It is created for a more complex data type by combining simpler data type and adding capabilities. 

A variable name 'class' can not be created inside the program. 
(note) PRIVATE is the default for the classes in C++.

If everything inside a class is PRIVATE, its of no use. We need special tools to access the data inside called MUTATORS(setter) and ACCESSORS(getter).

If we are not changing the data, we should warn C++ that we will not be making changes by marking the function as a constant.  Constant member function cannot change the data and are the only functions that can be called if the object is constant. 

CONSTRUCTOR: When an object is created, its member data could have garbage values. We should not allow this. Object Oriented Programming menas that we will never have invalid values, even if its just created. 

so CONSTRUCTORs help to initialize the member data of the object whenever the object is created. 

** The default constructor is a function named exactly same as the name of the class( case sensitive), with NO return type and NO parameters. 
** Member Initialization list : is the part of the constructor. It has is basically initialization outside the curls of constructor. 
** Only one constructor can be called in a class. And only the class that is called that will only be called. Default constructor will not be called by default unless it is called. 

'this' pointer: It is a feature of C++. 'this' pointer points to object itself. eg. when we call d1.setyear(), the 'this' operator is pointing to object Date in side the setyear() function. 
e.g. void setYear(int newYear){ this -> year = newYear; }  // Although it is not necessary but we can use 'this' pointer here.

OPERATING OVERLOADING ( Exclusive to C++ ) : This are just functions wiht strange function calls.
e.g.  a + b  is a function to call either 
     1.  operator+(a + b)
            or 
     2.  a.operator+(b). // As a member
Some operators can not be overloaded in C++. They are namely:
.  ,  ::  , *.  , sizeof , ?:

Some can be overloaded as member:
= ( assign operator)
[] ( array index operator )

Some , almost, cannot be overloaded as a member:
<< , >>

How to choose between Member vs. Non-Member operator definition ?

- Members have access to the PRIVATE.
- A function defined as a 'friend' in the class is NOT a member but will have access to PRIVATE. 
- a + b will work in both the cases
- a + 5 (object + constant) will work if there is a CONSTRUCTOR which can take 5 as a value and construct an object to add to a.
- 5 + a (constant + object) will only work if the above CONSTRUCTOR exists and operator+ is a non-member.

CLASS contating dynamic memory:
******************************
example: 

class Thing{
  int* value;
public : 
        Thing(int newVal = 0) : value (new int (newVal)){}

};

int main(){
  Thing one(1); 
  Thing two(2);
  }





